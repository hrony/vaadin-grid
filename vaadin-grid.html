<link rel="import" href="vaadin-scroller.html">
<link rel="import" href="vaadin-grid-dynamic-columns-mixin.html">
<link rel="import" href="vaadin-grid-data-provider-mixin.html">
<link rel="import" href="vaadin-grid-array-data-provider-mixin.html">
<link rel="import" href="vaadin-grid-cell-click-mixin.html">
<link rel="import" href="vaadin-grid-scroll-mixin.html">
<link rel="import" href="vaadin-grid-selection-mixin.html">
<link rel="import" href="vaadin-grid-sort-mixin.html">
<link rel="import" href="vaadin-grid-row-details-mixin.html">
<link rel="import" href="vaadin-grid-filter-mixin.html">
<link rel="import" href="vaadin-grid-column-reordering-mixin.html">
<link rel="import" href="vaadin-grid-column-resizing-mixin.html">
<link rel="import" href="vaadin-grid-column.html">
<link rel="import" href="vaadin-grid-outer-scroller.html">
<link rel="import" href="vaadin-grid-styles.html">

<dom-module id="vaadin-grid">
  <template>
    <style include="vaadin-grid-styles"></style>

    <div id="scroller" no-scrollbars$="[[_noScrollbars]]" safari$="[[_safari]]" ios$="[[_ios]]" scrolling$="[[scrolling]]">
      <table id="table">
        <thead id="header"></thead>
        <tbody id="items"></tbody>
        <tfoot id="footer"></tfoot>
      </table>

      <vaadin-grid-outer-scroller id="outerscroller"
          scroll-target="[[scrollTarget]]"
          scroll-handler="[[_this]]">
        <div id="outersizer" style$="top: [[_estScrollHeight]]px"></div>
      </vaadin-grid-outer-scroller>
    </div>

    <!-- The template needs at least one slot or else shady doesn't distribute -->
    <slot name="nodistribute"></slot>

  </template>
</dom-module>

<script>
  class VaadinGrid extends
    Vaadin.Grid.DataProviderMixin(
    Vaadin.Grid.ArrayDataProviderMixin(
    Vaadin.Grid.DynamicColumnsMixin(
    Vaadin.Grid.CellClickMixin(
    Vaadin.Grid.ScrollMixin(
    Vaadin.Grid.SelectionMixin(
    Vaadin.Grid.SortMixin(
    Vaadin.Grid.RowDetailsMixin(
    Vaadin.Grid.FilterMixin(
    Vaadin.Grid.ColumnReorderingMixin(
    Vaadin.Grid.ColumnResizingMixin(
    VaadinScroller))))))))))) {

    static get is() {
      return 'vaadin-grid';
    }

    static get observers() {
      return [
        '_columnTreeChanged(_columnTree, _columnTree.*)',
      ]
    }

    static get properties() {
      return {

        _safari: {
          type: Boolean,
          value: /^((?!chrome|android).)*safari/i.test(navigator.userAgent)
        },

        _this: {
          type: Object,
          value: function() {
            return this;
          }
        },

        _ios: {
          type: Boolean,
          value: function() {
            return navigator.userAgent.match(/iP(?:hone|ad;(?: U;)? CPU) OS (\d+)/);
          }
        }

      }
    }

    _createScrollerRow() {
      const row = document.createElement('tr');
      row.classList.add('vaadin-grid-row');
      this._updateRow(row, this._columnTree[this._columnTree.length - 1]);
      return row;
    }

    _getRowTarget() {
      return this.$.items;
    }

    _createCell() {
      const contentId = this._contentIndex = this._contentIndex + 1 || 0;
      const slotName = 'vaadin-grid-cell-content-' + contentId;

      const cellContent = document.createElement('vaadin-grid-cell-content');
      cellContent.setAttribute('slot' , slotName);

      const cell = document.createElement('td');
      cell.classList.add('vaadin-grid-cell');

      const slot = document.createElement('slot');
      slot.setAttribute('name', slotName);
      cell.appendChild(slot);

      return {cellContent, cell};
    }

    _updateRow(row, columns, templateName, isColumnRow) {
      templateName = templateName || 'template';

      const cellsFragment = document.createDocumentFragment();
      const contentsFragment = document.createDocumentFragment();

      row.innerHTML = '';
      columns.forEach((column, index) => {
        const {cellContent, cell} = this._createCell();
        contentsFragment.appendChild(cellContent);

        cell._content = cellContent;
        cell._column = column;
        row.appendChild(cell);

        column._cells = column._cells || [];
        if (templateName === 'template') {
          column._cells.push(cell);

          if (index === columns.length - 1 && this._rowDetailsTemplate) {
            // Add details cell as last cell to body rows
            const {cellContent, cell} = this._createCell();
            contentsFragment.appendChild(cellContent);
            cell._content = cellContent;
            this._configureDetailsCell(cell);
            row.appendChild(cell);
          }

          if (column.notifyPath) {
            column.notifyPath('_cells.*', column._cells); // TODO: This is really heavy, batch/debounce it
          }
        } else if (templateName === 'headerTemplate') {
          if (isColumnRow || column.localName === 'vaadin-grid-column-group') {
            column._headerCell = cell;
          } else {
            column._emptyCells = column._emptyCells || [];
            column._emptyCells.push(cell);
          }
        }
        else if (templateName === 'footerTemplate') {
          if (isColumnRow || column.localName === 'vaadin-grid-column-group') {
            column._footerCell = cell;
          } else {
            column._emptyCells = column._emptyCells || [];
            column._emptyCells.push(cell);
          }
        }
      });

      // row.appendChild(cellsFragment);

      // Might be empty if only cache was used
      this.appendChild(contentsFragment);

      this._frozenCellsChanged();
    }

    _updateScrollerItem(row, index) {
      const columns = this._columnTree[this._columnTree.length - 1];
      // Polymer.Templatizer.modelForElement(row)
      columns.forEach((column, columnIndex) => {
        const cell = row.children[columnIndex];
        const slot = cell.firstElementChild;

        if (cell._instance) {
          cell._instance.index = index;
        }
      });
      this._getItem(index, row);
    }

    _columnTreeChanged(columnTree, splices) {
      Array.from(this.$.items.children).forEach(this._updateRow.bind(this, columnTree[columnTree.length - 1]));

      // TODO: DRY
      while (this.$.header.children.length < columnTree.length) {
        const headerRow = document.createElement('tr');
        headerRow.classList.add('vaadin-grid-row');
        this.$.header.appendChild(headerRow);

        const footerRow = document.createElement('tr');
        footerRow.classList.add('vaadin-grid-row');
        this.$.footer.appendChild(footerRow);
      }
      while (this.$.header.children.length > columnTree.length) {
        this.$.header.removeChild(this.$.header.firstElementChild);
        this.$.footer.removeChild(this.$.header.firstElementChild);
      }

      Array.from(this.$.header.children).forEach((headerRow, index) => {
        this._updateRow(headerRow, columnTree[index], 'headerTemplate', index === columnTree.length - 1);
      });

      Array.from(this.$.footer.children).forEach((footerRow, index) => {
        this._updateRow(footerRow, columnTree[columnTree.length - 1 - index], 'footerTemplate', index === 0);
      });

      // Sizer row
      this._updateRow(this.$.outersizer, columnTree[columnTree.length - 1]);

    }

    _updateItem(row, item) {
      // row.style.minHeight = item ? '' : this.$.scroller._physicalAverage + 'px';
      row._item = item;
      Array.from(row.children).forEach((cell) => {
        if (cell._instance) {
          cell._instance.item = item;
          cell._instance.__expanded__ = this._isExpanded(item);
          cell._instance.expanded = this._isExpanded(item);
          // TODO: selected
        }
      });
      if (this._rowDetailsTemplate) {
        this._toggleDetailsCell(row, item);
      }
      // row.selected = this._isSelected(item);
      // row.expanded = this._isExpanded(item);
      // row.active = item !== null && item == this.activeItem;
      // row.focused = row.index === this.$.items._focusedRowIndex;
    }
  }

  customElements.define(VaadinGrid.is, VaadinGrid);
</script>
